# 计算机基础知识点合集


## 计网

### 1. TCP/IP网络层次结构

从上到下依次为：
应用层，传输层，网络层，数据链路层和物理层

![avatar](./img/cs/1.png)

### 1. TCP三次握手和四次挥手

#### 1.1 三次握手

TCP连接的建立需要三次握手过程，三次握手过程如下图所示：
![avatar](./img/cs/2.png)

(1) 客户端先送syn报文，生成一个随机的发送序号X
(2) 服务器端接受syn报文，发送syn的ACK报文(syn=1, ACK=1),同时生成一个随机的序号，置seq=Y，ack=X+1,然后发送回客户端
(3) 客户端发送ack报文，ACK=1, Seq=X+1, ack=Y+1

关于三次握手的一些问题：

- <b>在(1)(2)中为什么要生成随机的序号来发送文件，不是从1开始？</b>

答：这是出于安全的考虑，如果每次都是从序号1开始，那么攻击者可以伪造假的数据包向服务器发送，可以获取服务器数据或者攻击服务器。

- <b>如果在(3)中，服务器没有收到客户端发送的报文，会出现什么情况？</b>

答： 如果在(3)之后，客户端发送了报文，服务器没有收到，那么服务器会间隔一定的时间再一次发送报文(2)，收到回复的话连接成功，否则再次请求重发。当重发次数达到一定时，服务器端关闭连接，不再发送报文。

- <b>SYN攻击是什么？如何避免？</b>

答：SYN攻击是典型的DDOS攻击，与第二个回答有关。也就是攻击者伪造许多客户端向服务器发送大量请求连接的报文，然后不予回复，使得服务器不断给伪造的客户端重发报文，消耗网络资源，导致正常的连接请求被阻塞，使得服务器崩溃。
检测SYN攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击。较新的TCP/IP协议栈做了一定的修改来防范SYN攻击，比如增加最大半连接，缩短超时时间等。但不能完全避免。

- <b>为什么是三次握手？两次不行吗？</b>

答： 三次握手是为了防止已经失效的连接又发到服务器。如果客户端第一次发送报文后网络延迟了没有达到，然后重发了报文，连接成功。若此时第一次发送的报文又发送回服务器，那么服务器会以为这是客户端发起的第二个连接请求，然后又进行连接。但是此时客户端并没有向第二个连接传数据，导致了资源被白白浪费。


#### 1.2 四次挥手

TCP连接的断开需要经历四次挥手的过程。客户端和服务器均可主动发起挥手过程，在socket网络编程中可以使用close()函数来开始挥手的过程。四次挥手过程如下：

(1)  主动关闭的一方发送fin报文，fin=1。告诉被动方我的数据发完了，不会再发了。但仍然可以接收数据。
(2)  被动方回一个ack报文，表示我知道了。然后可以继续发数据。
(3)  被动方数据发送完后，发送fin报文，告知主动方，我的数据也发完了。
(4)  主动方回一个ack报文，然后等待2MSL时间后关闭连接。被动方收到最后一个报文后关闭连接。

![avatar](./img/cs/3.png)

关于四次挥手中的问题：

- <b>为什么(4)之后要等待2MSL的时间？</b>

答：因为要等待被动方接收到最后一次ACK报文。若立即关闭，发生丢包时，被动方一直接收不到最后一个确认报文，会处于无法正常关闭连接的状态。同时，等待的时间可以使本次连接持续时间内所有产生的报文段消失，保证在下一次新连接中不会出现旧连接遗留的请求报文段。

### TCP拥塞控制

在某一个时段，对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能变化，就发生了网络拥塞。TCP协议一般通过报文丢失，发送方启动超时重传来判断是否发生了拥塞， 并使用慢开始和拥塞避免来进行拥塞控制。
TCP拥塞控制的过程如下：开始时设置一个初始门限值ssthresh，swnd是发送方能发送的报文数量，cwnd是滑动窗口。

- 慢开始：初始时，cwnd=1，swnd=cwnd。当接收方接收到报文后，发送确认报文，若确认报文成功抵达发送方，说明网络状态好，没有发送拥塞，cwnd值=2。若下一回合仍然没有拥塞，cwnd=4。即cwnd在慢开始阶段呈指数增长趋势，swnd=cwnd。

- 拥塞避免： 当cwnd窗口值达到了初始门限值ssthresh，则进入拥塞避免阶段。此阶段cwnd不再呈指数增长，而是线性增长，每次增加1。若在进入拥塞避免后发送方启动了重传，则说明网络可能出现了拥塞，ssthresh值设置为当前cwnd窗口值的一半，cwnd设为1，重新进入慢开始阶段。

![avatar](./img/cs/4.png)

上面是一开始提出的拥塞避免算法，后来又增加了快速重传和快恢复来提高TCP性能。
有时报文丢失了，发生了超时重传，但是此时网络并没有发生拥塞，用上面的机制会导致传输效率变低。于是提出了快重传和快恢复。

- 快重传：发送方发送swnd个报文，即使发生了报文丢失也继续发送报文，然后等待丢失报文的响应。接收方接收到乱序的报文后，发送所缺失的报文之前的确认报文，（如丢失3号报文，就发送2号报文的确认），若后面继续收到乱序报文，就继续发送2号确认。当发送方收到3次重复的确认报文后，立即重传3号报文，而不需要等待超时重传。当接收方接收到3号报文后，发送接收到的最后一个报文的确认。表示此报文之前的报文都已经收到了。

- 快恢复： 当启动了快重传，说明网络有可能会发生拥塞，于是启动快恢复。快恢复阶段将ssthresh和cwnd设置为当前窗口的一半，然后开始拥塞避免算法。

![avatar](./img/cs/5.png)


#### Http协议get、post区别：
不带参数时，get, post只有报文前面的方法名不同。带参数情况下，get的参数在报文url上，post在报文body部分。（但这两种参数的写法并不是固定的）

在http协议上，这两种方法都不安全，数据都是可见的，若想要安全需要使用https协议。

get方法长度限制？
http协议本身对Body和url长度没有限制，部分浏览器和服务器会对url进行限制，主要是为了防止url太长不方便处理。

#### Http和Https的区别：

Https是利用http和SSL/TLS算法来加密数据的协议。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。Https工作在TCP的443端口，主要工作流程为:
1、TCP 三次同步握手
2、客户端验证服务器数字证书
3、DH 算法协商对称加密算法的密钥、hash 算法的密钥
4、SSL 安全加密隧道协商完成
5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。

![avatar](./img/cs/6.png)


#### Http长连接和短连接

- 短连接：客户端和服务器每次进行Http操作都需要进行一次连接
- 长连接：一个网页打开完成后，客户端和服务器之间的连接在一定时间内不会断开，客户端再次访问时仍然使用之前的连接，避免了多次重复的连接操作，节省网络资源。通过设置`Connection: keep-alive`来是连接变成长连接。

## 操作系统

### 进程相关

#### 进程和线程的区别：

进程是操作系统中最重要的抽象概念之一，是资源分配的基本单位，是独立运行的基本单位。可以看成是运行中的程序实例。进程由进程控制块，程序段，数据段组成。进程控制块是进程存在的唯一标志，包括进程标识符，进程当前状态，程序和数据地址，进程优先级，CPU现场保护区（用于进程切换），占有的资源清单等。

线程是操作系统可识别的任务调度的最小单位，是进程划分的任务，可以实现进程内部的并发。每个线程完成不同任务，但是同一进程的线程之间共享同一空间（但又有所不同，以JVM为例，PC和栈不同，堆和方法区数据相同。）

#### 为什么需要线程？

1、 进程在同一时刻只能完成一个任务，有时会导致资源利用率低
2、 进程在被阻塞或出现错误时会被挂起，导致其他不依赖该资源的任务也不能运行，所以需要线程来解决这两个问题。

#### 进程的状态和转换

##### 1、 三态模型

三态模型包括就绪态，阻塞态和运行态。

- 就绪态：程序已经做好运行准备，获得运行所需要的资源，只需要等待cpu资源即可运行

- 阻塞态： 进行中的任务为了等待某一事件的完成而停止运行，比如（I/O请求， 申请缓存失败）

- 运行态： 进程获得了CPU，正在执行任务。

![avatar](./img/cs/7.png)

##### 2、 五态模型

五态模型相对于三态模型，增加了新建状态和终止状态。

- 新建状态：创建一个新的进程，主要步骤包括：申请一个空白PCB，并向PCB中填写用于控制和管理进程的信息；为进程分配运行时所需要的资源；将进程转入就绪状态并插入就绪队列。

- 终止状态：终止一个进程，进程终止后不能再继续执行。等待操作系统做善后处理，将其PCB清零，并将PCB空间返还给系统 

![avatar](./img/cs/8.png)

##### 3、 挂起状态

挂起状态的引入：
挂起状态可以是程序主动挂起，也可以是操作系统因为某些原因而将进程挂起。可能的原因包括：用户的请求，父进程的请求，操作系统的需要，负载调节的需要等。

加入挂起状态后，引入了两个新的进程状态：就绪挂起状态和阻塞挂起状态。

![avatar](./img/cs/9.png)

挂起状态和阻塞状态的区别：

1)是否释放CPU？ 阻塞状态任务释放CPU，其他任务可以执行。挂起不释放CPU，如果任务优先级高则其他任务无法运行，一般挂起状态发生在程序调试时的条件中断。

2)是否是主动行为？ 阻塞是被动行为，是因为等待某个事件的完成而进入阻塞，比如wait(), lock()方法。挂起是主动行为，不释放CPU，等待CPU激活。比如sleep()方法。

3)挂起状态下任务调度器会忽略该任务。

sleep()， wait()方法的区别与联系：

这两个方法都是使程序等待n毫秒。
sleep()方法不释放锁，wait()释放锁，其他线程可以执行。
sleep()方法不释放cpu。

##### 4、进程间通信方式

- 匿名）管道：一种半双工的通信方式，数据只能在一个方向流动，且通常是有亲缘关系的进程之间才可以通信。如父子进程。

- 命名管道：同样是半双工通信，但是无亲缘关系的进程之间也可以通信。

- 消息队列：由消息组成的链表，存在内存中由消息队列标识符标识。消息队列客服了信号传递信息少，管道只能传递字节流以及缓存区大小受限的缺点。

- 共享内存： 一段可以被其他进程访问的内存，往往需要配合信号量的使用来实现进程间的通信和同步。

- 信号量： 信号量是一个计数器，用于控制进程对共享资源的访问。常常作为一种锁机制，防止同一时间段有多个进程对同一资源进行访问。

- 套接字： 套接字可以用于不同机器间的进程通信。

- 信号： 用于通知进程某个事件以及发生。

##### 5、进程调度策略

- FCFS先来先服务：先到达的进程先处理。
优点： 简单易理解，公平
缺点：有利于长进程，不利于短进程。有利于cpu繁忙的进程，不利于I/O繁忙的进程。

- 最短作业优先（SJF）：执行事件短的进程先处理。
优点：相对于FCFS可以改善平均周转事件和平均带权周转时间，缩短进程的等待时间，提高系统的吞吐量。
缺点：对长进程非常不利，可能长时间得不到执行。

- 最高相应比优先：R=(W+T)/T=1+W/T
其中，T是进程执行需要的时间，W是进程等待的时间。每次调度时对每个作业的相应比进行计算，然后将R最大的作业投入运行。
优点：长作业也有机会运行。
缺点：每次调度都要计算相应比，系统开销增加。

- 时间片轮转算法： 为每个进程分配一个时间段，称为他的时间片，即该进程允许运行的时间。
优点：简单易行，平均响应时间短。
缺点：不利于处理紧急作业。

- 高优先权优先调度：优先级高的进程先执行。
非抢占式： 一旦cpu分配给某进程，该进程就一直运行直至结束。
抢占式：如果一个进程正在运行，此时来了一个优先级更高的进程，那么该进程停止运行，将cpu让给优先级更高的进程。

### 内存管理

#### 1、为什么要有逻辑地址？

答：程序在编写的时候往往不知道最后被存储在哪里，也不确定需要使用多大的空间。为了方便程序的编写，对用户屏蔽了内存管理细节，让每个用户都以为自己有最大的内存空间。然后操作系统对用户编写的程序进行逻辑地址到物理地址的映射。

#### 2、逻辑地址到物理地址怎么映射？

答：主要有分页式，分段式和段页结合式。

- 分页式：将物理地址分为相同大小的一块，称为页，一般情况下32位系统的一页是1KB。将逻辑地址通过页号和页内偏移来映射成对应的物理地址。这种方式不会产生外部碎片，但是会有内部碎片。

- 分段式： 将物理地址分为大小不同的块，称为段，每段的大小可以不同。通过段号和段内偏移来映射成对应的物理地址。这种方式不会有内部碎片，但是有外部碎片。

- 段页式：结合了以上两种方式，对物理地址先分段，再分页。寻址的时候用段号+页号+页内偏移来完成。
